
# Aimyable Architecture Overview

### 1. Overview:
At a high level, Aimyable is designed to handle large projects that consist of smaller, more manageable tasks, which are then broken down into executable instructions. The system allows user interaction to query, alter, and schedule these projects and tasks via natural language prompts.

- **Top-Level Elements:**
  - **Projects**: The highest-level unit, representing a collection of tasks aimed at fulfilling a specific goal.
  - **Tasks**: Sub-units within a project that break down the overall goal into manageable pieces.
  - **Instructions**: Each task is further divided into instructions in JSON format, ready for execution by various engines.
  - **Actions**: The smallest execution units, such as taking a screenshot or moving a mouse, handled by the Mini-RPA.

### 2. Projects:
Projects represent high-level goals, such as "Check emails from multiple vendors and create bills for each." Projects are dynamic and can be:

- **Created**: Using user prompts.
- **Scheduled**: For specific times (e.g., weekly, daily).
- **Queried**: Users can ask about the status or progress of a project.
- **Altered**: Users can modify the schedule or details of an existing project.

Projects will be stored in both:
- **Vector Database**: To enable quick retrieval and efficient querying.
- **MongoDB**: For structured data management and historical record-keeping.

### 3. Task Generation (LLM-Driven):
For each project, tasks are generated by an **LLM-based engine**. The system uses natural language processing to convert a project prompt into multiple tasks, each representing a small unit of work aimed at achieving the overall project goal.

- Example Task: "Open Outlook, check for an email from xyz@gmail.com, create a bill in QuickBooks."

Tasks are stored similarly in:
- **MongoDB Database**: For task tracking and auditing.
- **Vector Database**: For quick querying and task suggestions.

### 4. Task Breakdown into Instructions:
Each task is broken down into executable **instructions** using a dedicated engine. Instructions are stored in a structured JSON format and contain fields such as:

```json
{
    "engine": "<engine_name>",
    "instruction": "<details_of_instruction>",
    "memory_key": "<temporary_storage_key>",
    "custom": "<optional_custom_user_input>"
}
```

Instructions are stored in both the MongoDB database and the vector database for future querying and historical tracking.

### 5. Instructions Executed via Engines:
Instructions are executed by the following engines:

- **App Opening Engine**: Responsible for launching desktop or web apps (e.g., Outlook, QuickBooks).
- **Instruction Execution Engine**: Handles all task instructions using tools like YOLO, Google Vision, and LLMs to generate and execute actions.
- **Custom Instruction Handling**: Users can fine-tune instructions during the process (e.g., "Use the top menu instead of the side menu in QuickBooks").
- **Temporary Memory (MongoDB)**: Intermediate data (e.g., email content, attachments) is stored for use across instructions.

### 6. Actions & Mini-RPA:
At the lowest level, instructions are further broken into **actions** that are executed by the **Mini-RPA** deployed on a desktop. The Mini-RPA handles:

- **Simple Actions**: Like taking a screenshot, moving the mouse, or interacting with UI components.
- **Server Communication**: It takes screenshots, sends them to the server for action prediction, and receives instructions on the next steps.
- **User Invocation of Actions**: Users can directly invoke actions from the prompt, such as "Take a screenshot," which will be detected as an action and executed accordingly.

### 7. Detecting and Routing User Commands:
A top-level **Command Detection Engine** will classify user input and route it to the appropriate engine:

- **Project Level**: High-level user commands like "Create a project" or "Check the project schedule."
- **Task Level**: Mid-level commands such as "Complete this task" or "Reschedule a task."
- **Instruction Level**: Lower-level commands breaking a task into smaller steps, like "Open an email and create a bill."
- **Action Level**: Fine-grained commands such as "Take a screenshot" or "Click the submit button."

The system will handle commands in JSON format:

```json
{
    "level": "PROJECT",
    "command": "<command_details>",
    "args": {
        "custom": "<user_specified_modifications>"
    }
}
```

### 8. Conversational History & Database Storage:
All user interactions and conversations are stored for later retrieval and contextual continuity:
- **Vector Database**: Used to store conversation history for quick lookup and dynamic interaction continuity.
- **MongoDB**: Stores a structured log of all interactions, tasks, projects, and instructions for long-term tracking.

### 9. DevOps & Processing Infrastructure:
- **Queue(part of MongoDB database)**: A task queue where instructions are passed for asynchronous processing.
- **Mini-RPA & Server Interaction**: The Mini-RPA continuously pulls instructions from the queue, executes actions, and sends feedback (screenshots) to the server for further processing.
- **Caching & Optimization**: Frequently used tasks, instructions, and actions will be cached to optimize performance and reduce redundant processing.

### 10. Additional Features:
- **Fine-Tuned Control for Users**: Users can issue precise commands to influence how tasks are executed, and these custom inputs are passed down through the task decomposition process.
- **Memory Handling**: Memory keys are used to store intermediate results, which can be retrieved by future instructions, making the process highly modular.
- **User Queries**: Users can dynamically inquire about tasks, projects, schedules, and progress at any point in the process.

### Summary:
The Aimyable architecture handles a comprehensive task lifecycleâ€”from high-level project planning to task execution and individual actions. The architecture is driven by engines, including an LLM-based task generator, app-opening mechanisms, and an instruction execution system, while also supporting direct user control through fine-tuning and dynamic queries. All data is stored and managed efficiently using a combination of vector databases and MongoDB, ensuring both real-time retrieval and long-term storage.

